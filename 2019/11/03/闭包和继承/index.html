<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>闭包和继承 | YOYO</title><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">闭包和继承</h1><a id="logo" href="/.">YOYO</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">闭包和继承</h1><div class="post-meta"><a href="/2019/11/03/%E9%97%AD%E5%8C%85%E5%92%8C%E7%BB%A7%E6%89%BF/#comments" class="comment-count"></a><p><span class="date">Nov 03, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h5 id="什么是闭包："><a href="#什么是闭包：" class="headerlink" title="什么是闭包："></a>什么是闭包：</h5><p>闭包的概念：闭包就是函数嵌套时，让局部变量变成自由变量的环境，是一种让局部变量进化的方式<br>（简单来说就是在函数内部书写函数，利用函数调用局部的变量）</p>
<h5 id="闭包的应用场景："><a href="#闭包的应用场景：" class="headerlink" title="闭包的应用场景："></a>闭包的应用场景：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);        <span class="comment">//可以访问到每次的i</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    必须满足两个条件：</span><br><span class="line">        <span class="number">1.</span>在<span class="keyword">for</span>循环内存在函数</span><br><span class="line">        <span class="number">2.</span>函数内会调用这个变量</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ali = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        ali[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);        <span class="comment">//在函数内部就无法访问到外部变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    如何形成闭包</span><br><span class="line">    <span class="keyword">var</span> ali = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">            ali[a].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line">    一旦内部函数调用外部函数的局部变量，那么这个时候，这个局部变量就会变成内部函数的私有变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二、当需要给setTimeout的回调函数传参时：</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">//两秒后，undefined</span></span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">    或</span><br><span class="line">    setTimeout(fn(<span class="number">10</span>), <span class="number">2000</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">//没有延迟，直接打印10</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    使用闭包：</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(a); <span class="comment">//两秒后，10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> f = fn(<span class="number">10</span>);</span><br><span class="line">    setTimeout(f, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<h6 id="闭包的特点："><a href="#闭包的特点：" class="headerlink" title="闭包的特点："></a>闭包的特点：</h6><p>闭包是把函数内部和函数外部连接起来的桥梁<br>可以读取函数内部的变量<br>让这些变量的值，始终保存在内存中，不会在调用结束后被系统回收<br>避免全局变量命名空间的污染<br>内存会消耗很大，不能滥用<br>闭包会在父函数外部，改变父函数内部变量的值</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>1.构造函数继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在构造函数中，同样属于两个新创建的函数，也是不相等的</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> obj1 = <span class="keyword">new</span> Fn(<span class="string">"AAA"</span>);</span><br><span class="line">    <span class="keyword">var</span> obj2 = <span class="keyword">new</span> Fn(<span class="string">"BBB"</span>);</span><br><span class="line">    obj1.show()</span><br><span class="line">    obj2.show()</span><br><span class="line">    </span><br><span class="line">    此时，任何一个<span class="keyword">new</span>出来的实例上都有了show方法，可以视为最基础的继承。</span><br></pre></td></tr></table></figure>

<p>2.call/apply继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">skill</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.skill = skill;</span><br><span class="line">        <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">"我会"</span>+<span class="keyword">this</span>.skill);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">abc</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//这里的this指向函数Son的实例化对象</span></span><br><span class="line">        <span class="comment">//将Father里面的this改变成指向Son的实例化对象，当相遇将father里面所有的属性和方法都复制到了son身上</span></span><br><span class="line">        <span class="comment">//Father.call(this,abc);//继承结束，call适合固定参数的继承</span></span><br><span class="line">        <span class="comment">//Father.apply(this,arguments);//继承结束，apply适合不定参数的继承</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="keyword">new</span> Father(<span class="string">"绝世木匠”);</span></span><br><span class="line"><span class="string">    var s = new Son("</span>一般木匠<span class="string">");</span></span><br><span class="line"><span class="string">    f.show()</span></span><br><span class="line"><span class="string">    s.show();</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    优点：</span></span><br><span class="line"><span class="string">        创建子类实例时，可以向父类的构造器传参；</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    缺点：</span></span><br><span class="line"><span class="string">        只能继承构造器中定义的属性和方法，不能继承原型上定义的属性和方法</span></span><br></pre></td></tr></table></figure>

<p>3.prototype的概念：</p>
<p>原型对象<br>指针 constructor表示当前函数属于谁，用来指向当前原型所属的函数<br>原型指针[prototype] proto 相当于一根原型指针，指向当前对象的“父级”。<br>可以在当前函数的原型上添加方法和各种属性，以供使用<br>JS中万物皆对象，所有的内容的指针终点都指向Object。<br>4.原型链继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">方法一：Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line">    <span class="comment">//创建一个函数Father，用来做原始对象</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.skill = <span class="string">"铁匠"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    Father.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.skill)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个函数Son，准备继承Father的原型</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//将Son点原型，赋值为一个指针，指向Father的原型</span></span><br><span class="line">    Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时就可以通过执行new Son()获取到从构造函数Father上继承过来属性和方法</span></span><br><span class="line">    <span class="keyword">var</span> s = <span class="keyword">new</span> Son()</span><br><span class="line">    s.show();        <span class="comment">//铁匠</span></span><br><span class="line"></span><br><span class="line">    优点：</span><br><span class="line">        <span class="number">1.</span>可以访问父类原型上的方法和属性</span><br><span class="line">        <span class="number">2.</span>简单方便，易于实现</span><br><span class="line"></span><br><span class="line">    缺点：</span><br><span class="line">        <span class="number">1.</span>创建子类实例时，无法向父类的构造器传参</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">    <span class="comment">//创建一个函数Father，用来做原始对象</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.skill = <span class="string">"铁匠"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    Father.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hello world"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个函数Son，准备继承Father的原型</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//将Son的原型，设置为Father的原型</span></span><br><span class="line">    <span class="comment">//Son.prototype = Father.prototype;</span></span><br><span class="line">    <span class="comment">//但是这种拷贝方式为对象的浅拷贝，一旦后期修改Son原型上的方法，会影响到Father的原型</span></span><br><span class="line">    <span class="comment">//需采用对象的深拷贝方法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> Father.prototype)&#123;</span><br><span class="line">        Son.prototype[i] = Father.prototype[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Son.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"这是子类修改之后的show方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="keyword">new</span> Father()</span><br><span class="line">    f.show()</span><br><span class="line">    <span class="keyword">var</span> s = <span class="keyword">new</span> Son()</span><br><span class="line">    s.show();</span><br><span class="line">    </span><br><span class="line">    优点：</span><br><span class="line">        完全将父类原型上的方法和属性拷贝到子类原型</span><br><span class="line"></span><br><span class="line">    缺点：</span><br><span class="line">        只能继承原型上的方法和属性，构造函数无法传参和继承</span><br></pre></td></tr></table></figure>

<p>5.混合继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">        使用call或apply继承父类的构造器中的内容，使用原型继承，继承父类的原型</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">skill,id</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.skill = skill;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    Father.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"我是father,这是我的技能"</span>+<span class="keyword">this</span>.skill);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Father.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不做Son的原型继承Father的原型，此时会报错：son.show is not a function</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> Father.prototype)&#123;</span><br><span class="line">        Son.prototype[i] = Father.prototype[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为，如果不让Son的原型等于Father的原型，Son使用apply是继承不到原型上的方法</span></span><br><span class="line">    Son.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"我是son,这是我的技能"</span>+<span class="keyword">this</span>.skill);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="keyword">new</span> Father(<span class="string">"专家级铁匠"</span>,<span class="string">"father"</span>);</span><br><span class="line">    <span class="keyword">var</span> s = <span class="keyword">new</span> Son(<span class="string">"熟练级铁匠"</span>,<span class="string">"son"</span>);</span><br><span class="line">    f.show();</span><br><span class="line">    s.show();</span><br></pre></td></tr></table></figure>

<p>6.ES6的class继承方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        show()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>()&#123;</span><br><span class="line">            <span class="keyword">super</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        show()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="原型对象的相关概念"><a href="#原型对象的相关概念" class="headerlink" title="原型对象的相关概念"></a>原型对象的相关概念</h4><p>1.对象中的<strong>proto</strong>是什么：<br>js中万物皆对象，每个数据都会有一个<strong>proto</strong>的属性，这个属性叫隐式原型，一个对象(obj)的隐式原型(proto)指向构造该对象(obj)的构造函数(object())的原型属性(object.prototype)，这样做的原因是为了能够保证实例(obj)能够访问到在构造函数(object())的原型属性(object.prototype)中定义的属性和方法。</p>
<p>2.函数中的prototype是什么：<br>函数(Function)是一个特殊的对象，除了和其他对象一样有上述<strong>proto</strong>属性之外，还有自己特有的属性——原型（prototype），这个属性被描述成指针，他指向一个对象类型的数据，这个对象的用途就是包含所有将来使用该函数构造出来的可被共享的属性和方法（我们把这个对象叫做原型对象）。<br>原型对象内也有一个属性，叫做constructor，这个属性包含了一个指针，指回原函数（类似于arguments.callee。但是arguments只能在函数内部获得，而函数原型对象内的constructor属性，可以在任何能访问到这个函数的位置使用）。</p>
<p>3.构造函数，原型，实例之间的关系：<br>1&gt;构造函数Fn身上有属性prototype为原型对象，原型对象内有constructor属性指向当前prototype所在的构造函数Fn<br>2&gt;在new执行构造函数Fn时，创造了一个实例对象f，实例对象f的<strong>proto</strong>指向构造函数Fn的原型prototype<br>3&gt;因为实例对象f的<strong>proto</strong>指向构造函数Fn的原型prototype，所以实例对象f可以间接访问到Fn原型prototype的方法<br>4.查看实例对象f是否有指针指向构造函数Fn的原型：<br>isPrototypeOf()用于检测两个对象之间似乎否存在这种关系，使用方法如下：<br>Fn.prototype.isPrototypeOf(f) // 查看 Fn 的 prototype 对象，是否是 f 原型<br>类似的还有instanceof运算符，使用方法如下：<br>console.log(f instanceof Fn) // 查看 f 对象是否是构造函数 Fn 的实例<br>console.log(f instanceof Object)<br>两种使用，如果是返回ture，如果不是返回false<br>注意：instanceof运算符右侧为构造函数，并且js中所有原型都来自Object构造函数</p>
<p>[原文链接：<a href="https://blog.csdn.net/ZhangXiaoTianZC/article/details/102868542]" target="_blank" rel="noopener">https://blog.csdn.net/ZhangXiaoTianZC/article/details/102868542]</a>: </p>
</div><div class="post-copyright"><blockquote><p>原文作者: YOYO</p><p>原文链接: <a href="http://yoursite.com/2019/11/03/闭包和继承/">http://yoursite.com/2019/11/03/闭包和继承/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/11/10/Java%E4%BF%AE%E6%94%B9%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" class="pre">Java修改编码格式的几种方式</a><a href="/2019/10/31/%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8jsp%E5%86%99%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2/" class="next">怎样使用jsp写注册页面</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#什么是闭包："><span class="toc-text">什么是闭包：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#闭包的应用场景："><span class="toc-text">闭包的应用场景：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#闭包的特点："><span class="toc-text">闭包的特点：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原型对象的相关概念"><span class="toc-text">原型对象的相关概念</span></a></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/24/Java-super%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/">Java super关键字详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/24/Java%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%A6%E8%A7%A3/">Java构造函数的详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/24/Jsp%E5%92%8CServlet%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%B1%E5%90%8C%E7%82%B9%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB/">Jsp和Servlet有哪些共同点及其区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/21/%E9%A1%B5%E9%9D%A2%E4%B8%AD%E4%BC%A0%E9%80%92%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/">页面中传递对象的方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/21/ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BA%94%E4%B8%AA%E6%AD%A5%E9%AA%A4-1/">ajax请求的五个步骤</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/10/Java%E4%BF%AE%E6%94%B9%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">Java修改编码格式的几种方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/03/%E9%97%AD%E5%8C%85%E5%92%8C%E7%BB%A7%E6%89%BF/">闭包和继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/31/%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8jsp%E5%86%99%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2/">怎样使用jsp写注册页面</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/Eclipse%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AETomcat/">Eclipse环境下如何配置Tomcat</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/28/%E6%80%8E%E6%A0%B7%E5%9C%A8eclipse%E4%B8%AD%E4%BF%AE%E6%94%B9jsp%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%BAUTF-8/">怎样在eclipse中修改jsp的编码为UTF-8</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">YOYO.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>